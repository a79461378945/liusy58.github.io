---
title: 'Leetcode-3.13'
date: 2020-03-13
permalink: /posts/2020/03/blog-post-19/
tags:
  - Leetcode每日练
---

### 264. Ugly Number II
The key is to realize each number can be and have to be generated by a former number multiplied by 2, 3 or 5
e.g.
1 2 3 4 5 6 8 9 10 12 15..
what is next?
it must be x * 2 or y * 3 or z * 5, where x, y, z is an existing number.

How do we determine x, y, z then?
apparently, you can just traverse the sequence generated by far from 1 ... 15, until you find such x, y, z that x * 2, y * 3, z * 5 is just bigger than 15. In this case x=8, y=6, z=4. Then you compare x * 2, y * 3, z * 5 so you know next number will be x * 2 = 8 * 2 = 16.
k, now you have 1,2,3,4,....,15, 16,

Then what is next?
You wanna do the same process again to find the new x, y, z, but you realize, wait, do I have to
traverse the sequence generated by far again?

NO! since you know last time, x=8, y=6, z=4 and x=8 was used to generate 16, so this time, you can immediately know the new_x = 9 (the next number after 8 is 9 in the generated sequence), y=6, z=4.
Then you need to compare new_x * 2, y * 3, z * 5. You know next number is 9 * 2 = 18;

And you also know, the next x will be 10 since new_x = 9 was used this time.
But what is next y? apparently, if y=6, 6*3 = 18, which is already generated in this round. So you also need to update next y from 6 to 8.

Based on the idea above, you can actually generated x,y,z from very beginning, and update x, y, z accordingly. It ends up with a O(n) solution.
下面这种写法可以解决重复的问题，因为`if`是并列的，我们来举个例子因为6=3\*2=2\*3，

```c++
int nthUglyNumber(int n)
{
    vector<int>res(1,1);
    int index2=0,index3=0,index5=0;
    while(res.size()<n)
    {
        int temp2=res[index2]*2;
        int temp3=res[index3]*3;
        int temp5=res[index5]*5;
        int temp=min(temp2,min(temp3,temp5));
        
        if(temp==temp2)
            ++index2;
        if(temp==temp3)
            ++index3;
        if(temp==temp5)
            ++index5;
        
        res.push_back(temp);
    }
    return res.back();
    
}
```

### 260 Single Number 




* Let a and b be the two unique numbers
XORing all numbers gets you (a xor b)
(a xor b) must be non-zero otherwise they are equal
* If bit_i in (a xor b) is 1, bit_i at a and b are different.
* Find bit_i using the low bit formula m & -m
* Partition the numbers into two groups: one group with bit_i == 1 and the other group with bit_i == 0.
* a is in one group and b is in the other.
* a is the only single number in its group.
* b is also the only single number in its group.
* XORing all numbers in a's group to get a
* XORing all numbers in b's group to get b
* Alternatively, XOR (a xor b) with a gets you b.


why`diff &= ~(diff - 1)`?

**..**10_00..00
after -1:
**..**01_11..11



```c++
  vector<int> singleNumber(vector<int>& nums) {
        int diff = accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());
        diff &= -diff;
        vector<int> res(2, 0);
        for (auto &a : nums) {
            if (a & diff) res[0] ^= a;
            else res[1] ^= a;
        }
        return res;
    }
```